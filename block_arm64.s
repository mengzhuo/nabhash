#include "textflag.h"

// func blockNEON(s *state, p []byte)
TEXT ·blockNEON(SB), NOSPLIT|NOFRAME, $0
	MOVD	s+0(FP), R0
	MOVD	p_base+8(FP), R1
	MOVD	p_len+16(FP), R2
	VLD1	(R0), [V0.B16, V1.B16, V2.B16, V3.B16]

	// X86 AESENC not having use AddRoundKey
	// AESENC key, state -> dst
	// MixColumns(ShiftRows(SubBytes(state))) ^ k -> dst
	// While ARM64 use
	// AESE	key, state -> state
	// AESMC state -> dst
	// MixColumns(ShiftRows(SubBytes(state ^ k))) -> dst
	VEOR	V10.B16, V10.B16, V10.B16

loop:
	VLD1.P	64(R1), [V4.S4, V5.S4, V6.S4, V7.S4]

	AESE	V10.B16, V0.B16
	AESMC	V0.B16, V0.B16
	AESE	V10.B16, V1.B16
	AESMC	V1.B16, V1.B16
	AESE	V10.B16, V2.B16
	AESMC	V2.B16, V2.B16
	AESE	V10.B16, V3.B16
	AESMC	V3.B16, V3.B16

	VEOR	V4.B16, V0.B16, V0.B16
	VEOR	V5.B16, V1.B16, V1.B16
	VEOR	V6.B16, V2.B16, V2.B16
	VEOR	V7.B16, V3.B16, V3.B16

	SUB	$64, R2
	CBNZ	R2, loop

	VST1	[V0.B16, V1.B16, V2.B16, V3.B16], (R0)
	RET


// func finalNEON(s *state, l uint64)
TEXT ·finalNEON(SB), NOSPLIT|NOFRAME, $0
	MOVD	s+0(FP), R0
	MOVD	l+8(FP), R1
	VLD1	(R0), [V0.B16, V1.B16, V2.B16, V3.B16]

	VEOR	V4.B16, V4.B16, V4.B16
	VEOR	V10.B16, V10.B16, V10.B16
	VMOV	R1, V4.D[0]

	VEOR	V4.B16, V0.B16, V0.B16
	VEOR	V4.B16, V1.B16, V1.B16
	VEOR	V4.B16, V2.B16, V2.B16
	VEOR	V4.B16, V3.B16, V3.B16

	AESE	V10.B16, V0.B16
	AESMC	V0.B16, V0.B16
	VEOR	V1.B16, V0.B16, V0.B16

	AESE	V10.B16, V2.B16
	AESMC	V2.B16, V2.B16
	VEOR	V3.B16, V2.B16, V1.B16

	AESE	V10.B16, V0.B16
	AESMC	V0.B16, V0.B16
	VEOR	V1.B16, V0.B16, V0.B16


	// AESENC X0, X0
	VMOV	V0.B16, V1.B16
	AESE	V10.B16, V0.B16
	AESMC	V0.B16, V0.B16
	VEOR	V0.B16, V1.B16, V0.B16

	VMOV	V0.B16, V1.B16
	AESE	V10.B16, V0.B16
	AESMC	V0.B16, V0.B16
	VEOR	V0.B16, V1.B16, V0.B16

	VMOV	V0.B16, V1.B16
	AESE	V10.B16, V0.B16
	AESMC	V0.B16, V0.B16
	VEOR	V0.B16, V1.B16, V0.B16

	VST1	[V0.B16], (R0)
	RET
